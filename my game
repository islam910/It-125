import random
    #создание ячейки
class Cell:
        def __init__(self):
          self.is_mine = False
          self.is_open = False
          self.is_flagged = False
          self.adjacent_mines = 0
    #данные сетки
class Gameboard:
    def __init__(self, width, height, mines_count):
          self.game_over = False
          self.width = width
          self.height = height
          self.mines_count = mines_count
          #создание спика и заполнение ее
          self.board = [[Cell() for _ in range(width)] for _ in range(height)]
          
    def open_cell(self, r, c):
      #открытие ячейки по которой кликнули
        cell = self.board[r][c]

    #нельзя открыть ячейку с флагом или пустую
        if cell.is_open or cell.is_flagged:
            return
        
        cell.is_open = True
       
         #если была мина 
        if cell.is_mine:
            self.game_over = True
            return

        #если ячейка пуста открываем соседей
        if cell.adjacent_mines == 0 and not cell.is_mine:
            #аналих всех 8 соседей
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                   #вычисление координат соседа 
                    nr, nc = r + dr, c + dc

                #сосед в пределах поля
                    if 0 <= nr < self.height and 0 <= nc < self.width:
                #рекурсивно вызываем эту функцию для соседа
                        self.open_cell(nr, nc)

    def toggle_flag(self, r, c):
        cell = self.board[r][c]
        # Флаг можно ставить только на закрытые ячейки
        if not cell.is_open:
            cell.is_flagged = not cell.is_flagged

def _place_mines(self):
        #возможность их расставления
        all_coords = [(r,c) for r in range(self.height)for c in range(self.width)]
        #выбирает случайные уникальные цифры координат для мин
        mine_coords = random.sample(all_coords, self.mines_count)
        #мины и цифры расставлялись при создании поле
        self._place_mines()
        self._calculate_adjacent_mines()
        #ставить мины
        for r, c in mine_coords:
            self.board[r][c].is_mine = True 

        def _calculate_adjacent_mines(self):
        #проходится по полю
           for r in range(self.height):
            for c in range(self.width):
                #если в ячейке мине
                if self.board[r][c].is_mine:
                    continue 

        mine_count = 0
        #проверка 8 соседей
        for dr in [-1, 0, 1]: #смещение по строке
         for dc in [-1, 0, 1]: #смещение по столбцу
            #пропускаем саму текущую ячейку
            if dr == 0 and dc == 0:
                continue
            
            #вычисление координат соседа 
            nr, nc = r + dr, c + dc

            #проверка что ячейка не за полем
            if 0 <= nr <= self.height and 0 <= nc < self.width:
                if self.board[nr][nc].is_mine:
                    mine_count += 1

        self.board[r][c].adjacent_mines = mine_count   

import pygame         

    #размеры поля в ячейках
BOARD_WIDTH = 20
BOARD_HEIGHT = 20
MINES_COUNT = 30

    #размер одной ячейки в пикселях
CELL_SIZE = 30

    #размер окна в пикселях
SCREEN_WIDTH = BOARD_WIDTH * CELL_SIZE
SCREEN_HEIGHT = BOARD_HEIGHT * CELL_SIZE 

    #цвета 
BG_COLOR = (192, 192, 192)
LINE_COLOR = (128, 128, 128)

    #инициализация pygame и создание окна
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Сапер")
 #добавление создание шрифта
font = pygame.font.SysFont('Arial', CELL_SIZE // 2)

    #создание игрового поля
Game_Board = Gameboard(BOARD_WIDTH, BOARD_HEIGHT, MINES_COUNT) 

def draw_board(board_obj):
        #красим поле
    screen.fill(BG_COLOR)

  #проходимся по каждой ячейке
    for r in range(board_obj.height):
        for c in range(board_obj.width):
            cell = board_obj.board[r][c]
            #расчет координат ячейк на экране в пикселях
            x = c * CELL_SIZE
            y = r * CELL_SIZE 
             #создание прям для ячейки 
            rect = pygame.Rect(x, y, CELL_SIZE , CELL_SIZE)
             #рисуем контур для ячейки
            pygame.draw.rect(screen, LINE_COLOR, rect, 1)
            #если ячейка открыта
            if cell.is_open:
                if cell.is_mine:
                #рисуем мину красный круг
                    pygame.draw.circle(screen, (255, 0, 0), rect.center, CELL_SIZE // 3)
                elif cell.adjacent_mines > 0:
                #рисуем цифру
                    text = font.render(str(cell.adjacent_mines), True, (0, 0, 0))
                    text_rect = text.get_rect(center=rect.center)
                    screen.blit(text, text_rect)
                #если стоит флаг
            elif cell.is_flagged:
                #рисуем флаг желтый треугольник
                pygame.draw.polygon(screen, (255, 255, 0),
                                    [(rect.left + 5, rect.top + 5),
                                     (rect.right - 5, rect.centery),
                                     (rect.left + 5, rect.bottom - 5)])
                                    
            #игровой цикл
running = True 
while running:
                #обработка событий 
    for event in pygame.event.get():
                    #если пользователь нажал на крестик
        if event.type == pygame.QUIT:
            running = False
            #нажатие мыши
        if event.type == pygame.MOUSEBUTTONDOWN and not Game_Board.game_over:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            clicked_col = mouse_x // CELL_SIZE
            clicked_row = mouse_y // CELL_SIZE



               #превращение пикселей в координаты ячеек
            clicked_col = mouse_x // CELL_SIZE
            clicked_row = mouse_y // CELL_SIZE 

             # Если левая кнопка мыши
            if event.button == 1:
                Game_Board.open_cell(clicked_row, clicked_col)
            
            # Если правая кнопка мыши
            elif event.button == 3:
                Game_Board.toggle_flag(clicked_row, clicked_col)
               #координаты клика в пикселях  

               #результат в терминал 
            print(f"Клик по ячейке: строка {clicked_row}, столбец {clicked_col}")
            #отрисовка
    draw_board(Game_Board)
     #поражение экран проигрыша
    board = Gameboard(10, 12, 19)
    if Game_Board.game_over:
        #полупрозрачный черный фон
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        screen.blit(overlay, (0, 0))

        #Текст
        text = font.render("Вы проиграли!", True, (255, 255, 255))
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
        screen.blit(text, text_rect)
            #обновление экрана 
    pygame.display.flip()
            #завершение работы
pygame.quit()
